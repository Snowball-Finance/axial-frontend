/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
  ethers,
  EventFilter,
  Signer,
  BigNumber,
  BigNumberish,
  PopulatedTransaction,
  Contract,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  CallOverrides,
} from "ethers";
import { BytesLike } from "@ethersproject/bytes";
import { Listener, Provider } from "@ethersproject/providers";
import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
import { TypedEventFilter, TypedEvent, TypedListener } from "./commons";

interface SwapRouterInterface extends ethers.utils.Interface {
  functions: {
    "ADAPTERS(uint256)": FunctionFragment;
    "AVAX()": FunctionFragment;
    "FEE_CLAIMER()": FunctionFragment;
    "FEE_DENOMINATOR()": FunctionFragment;
    "MIN_FEE()": FunctionFragment;
    "NAME()": FunctionFragment;
    "TRUSTED_TOKENS(uint256)": FunctionFragment;
    "WAVAX()": FunctionFragment;
    "adaptersCount()": FunctionFragment;
    "findBestPath(uint256,address,address,uint256)": FunctionFragment;
    "findBestPathWithGas(uint256,address,address,uint256,uint256)": FunctionFragment;
    "owner()": FunctionFragment;
    "queryAdapter(uint256,address,address,uint8)": FunctionFragment;
    "queryNoSplit(uint256,address,address,uint8[])": FunctionFragment;
    "recoverAVAX(uint256)": FunctionFragment;
    "recoverERC20(address,uint256)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "setAdapters(address[])": FunctionFragment;
    "setFeeClaimer(address)": FunctionFragment;
    "setMinFee(uint256)": FunctionFragment;
    "setTrustedTokens(address[])": FunctionFragment;
    "swapNoSplit(tuple,address,uint256)": FunctionFragment;
    "swapNoSplitFromAVAX(tuple,address,uint256)": FunctionFragment;
    "swapNoSplitToAVAX(tuple,address,uint256)": FunctionFragment;
    "swapNoSplitToAVAXWithPermit(tuple,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
    "swapNoSplitWithPermit(tuple,address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "trustedTokensCount()": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "ADAPTERS",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "AVAX", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "FEE_CLAIMER",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "FEE_DENOMINATOR",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "MIN_FEE", values?: undefined): string;
  encodeFunctionData(functionFragment: "NAME", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "TRUSTED_TOKENS",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "WAVAX", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "adaptersCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "findBestPath",
    values: [BigNumberish, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "findBestPathWithGas",
    values: [BigNumberish, string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "queryAdapter",
    values: [BigNumberish, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "queryNoSplit",
    values: [BigNumberish, string, string, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "recoverAVAX",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "recoverERC20",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setAdapters",
    values: [string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "setFeeClaimer",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setMinFee",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setTrustedTokens",
    values: [string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "swapNoSplit",
    values: [
      {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      string,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapNoSplitFromAVAX",
    values: [
      {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      string,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapNoSplitToAVAX",
    values: [
      {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      string,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapNoSplitToAVAXWithPermit",
    values: [
      {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapNoSplitWithPermit",
    values: [
      {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "trustedTokensCount",
    values?: undefined
  ): string;

  decodeFunctionResult(functionFragment: "ADAPTERS", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "AVAX", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "FEE_CLAIMER",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "FEE_DENOMINATOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "MIN_FEE", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "NAME", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "TRUSTED_TOKENS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "WAVAX", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "adaptersCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "findBestPath",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "findBestPathWithGas",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "queryAdapter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "queryNoSplit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "recoverAVAX",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "recoverERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAdapters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFeeClaimer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setMinFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setTrustedTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapNoSplit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapNoSplitFromAVAX",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapNoSplitToAVAX",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapNoSplitToAVAXWithPermit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapNoSplitWithPermit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "trustedTokensCount",
    data: BytesLike
  ): Result;

  events: {
    "OwnershipTransferred(address,address)": EventFragment;
    "Recovered(address,uint256)": EventFragment;
    "UpdatedAdapters(address[])": EventFragment;
    "UpdatedFeeClaimer(address,address)": EventFragment;
    "UpdatedMinFee(uint256,uint256)": EventFragment;
    "UpdatedTrustedTokens(address[])": EventFragment;
    "YakSwap(address,address,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Recovered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdatedAdapters"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdatedFeeClaimer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdatedMinFee"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdatedTrustedTokens"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "YakSwap"): EventFragment;
}

export class SwapRouter extends Contract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  listeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
  off<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  on<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  once<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
    listener: TypedListener<EventArgsArray, EventArgsObject>
  ): this;
  removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
    eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
  ): this;

  listeners(eventName?: string): Array<Listener>;
  off(eventName: string, listener: Listener): this;
  on(eventName: string, listener: Listener): this;
  once(eventName: string, listener: Listener): this;
  removeListener(eventName: string, listener: Listener): this;
  removeAllListeners(eventName?: string): this;

  queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
    event: TypedEventFilter<EventArgsArray, EventArgsObject>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;

  interface: SwapRouterInterface;

  functions: {
    ADAPTERS(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    "ADAPTERS(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    AVAX(overrides?: CallOverrides): Promise<[string]>;

    "AVAX()"(overrides?: CallOverrides): Promise<[string]>;

    FEE_CLAIMER(overrides?: CallOverrides): Promise<[string]>;

    "FEE_CLAIMER()"(overrides?: CallOverrides): Promise<[string]>;

    FEE_DENOMINATOR(overrides?: CallOverrides): Promise<[BigNumber]>;

    "FEE_DENOMINATOR()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    MIN_FEE(overrides?: CallOverrides): Promise<[BigNumber]>;

    "MIN_FEE()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    NAME(overrides?: CallOverrides): Promise<[string]>;

    "NAME()"(overrides?: CallOverrides): Promise<[string]>;

    TRUSTED_TOKENS(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    "TRUSTED_TOKENS(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    WAVAX(overrides?: CallOverrides): Promise<[string]>;

    "WAVAX()"(overrides?: CallOverrides): Promise<[string]>;

    adaptersCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    "adaptersCount()"(overrides?: CallOverrides): Promise<[BigNumber]>;

    findBestPath(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        [BigNumber[], string[], string[]] & {
          amounts: BigNumber[];
          adapters: string[];
          path: string[];
        }
      ]
    >;

    "findBestPath(uint256,address,address,uint256)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        [BigNumber[], string[], string[]] & {
          amounts: BigNumber[];
          adapters: string[];
          path: string[];
        }
      ]
    >;

    findBestPathWithGas(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      _gasPrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        [BigNumber[], string[], string[], BigNumber] & {
          amounts: BigNumber[];
          adapters: string[];
          path: string[];
          gasEstimate: BigNumber;
        }
      ]
    >;

    "findBestPathWithGas(uint256,address,address,uint256,uint256)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      _gasPrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        [BigNumber[], string[], string[], BigNumber] & {
          amounts: BigNumber[];
          adapters: string[];
          path: string[];
          gasEstimate: BigNumber;
        }
      ]
    >;

    owner(overrides?: CallOverrides): Promise<[string]>;

    "owner()"(overrides?: CallOverrides): Promise<[string]>;

    queryAdapter(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "queryAdapter(uint256,address,address,uint8)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "queryNoSplit(uint256,address,address,uint8[])"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _options: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<
      [
        [string, string, string, BigNumber] & {
          adapter: string;
          tokenIn: string;
          tokenOut: string;
          amountOut: BigNumber;
        }
      ]
    >;

    "queryNoSplit(uint256,address,address)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      overrides?: CallOverrides
    ): Promise<
      [
        [string, string, string, BigNumber] & {
          adapter: string;
          tokenIn: string;
          tokenOut: string;
          amountOut: BigNumber;
        }
      ]
    >;

    recoverAVAX(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "recoverAVAX(uint256)"(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    recoverERC20(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "recoverERC20(address,uint256)"(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "renounceOwnership()"(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setAdapters(
      _adapters: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "setAdapters(address[])"(
      _adapters: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setFeeClaimer(
      _claimer: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "setFeeClaimer(address)"(
      _claimer: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setMinFee(
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "setMinFee(uint256)"(
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setTrustedTokens(
      _trustedTokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "setTrustedTokens(address[])"(
      _trustedTokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapNoSplit(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "swapNoSplit((uint256,uint256,address[],address[]),address,uint256)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapNoSplitFromAVAX(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "swapNoSplitFromAVAX((uint256,uint256,address[],address[]),address,uint256)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapNoSplitToAVAX(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "swapNoSplitToAVAX((uint256,uint256,address[],address[]),address,uint256)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapNoSplitToAVAXWithPermit(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "swapNoSplitToAVAXWithPermit((uint256,uint256,address[],address[]),address,uint256,uint256,uint8,bytes32,bytes32)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapNoSplitWithPermit(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "swapNoSplitWithPermit((uint256,uint256,address[],address[]),address,uint256,uint256,uint8,bytes32,bytes32)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    "transferOwnership(address)"(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    trustedTokensCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    "trustedTokensCount()"(overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  ADAPTERS(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  "ADAPTERS(uint256)"(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  AVAX(overrides?: CallOverrides): Promise<string>;

  "AVAX()"(overrides?: CallOverrides): Promise<string>;

  FEE_CLAIMER(overrides?: CallOverrides): Promise<string>;

  "FEE_CLAIMER()"(overrides?: CallOverrides): Promise<string>;

  FEE_DENOMINATOR(overrides?: CallOverrides): Promise<BigNumber>;

  "FEE_DENOMINATOR()"(overrides?: CallOverrides): Promise<BigNumber>;

  MIN_FEE(overrides?: CallOverrides): Promise<BigNumber>;

  "MIN_FEE()"(overrides?: CallOverrides): Promise<BigNumber>;

  NAME(overrides?: CallOverrides): Promise<string>;

  "NAME()"(overrides?: CallOverrides): Promise<string>;

  TRUSTED_TOKENS(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  "TRUSTED_TOKENS(uint256)"(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  WAVAX(overrides?: CallOverrides): Promise<string>;

  "WAVAX()"(overrides?: CallOverrides): Promise<string>;

  adaptersCount(overrides?: CallOverrides): Promise<BigNumber>;

  "adaptersCount()"(overrides?: CallOverrides): Promise<BigNumber>;

  findBestPath(
    _amountIn: BigNumberish,
    _tokenIn: string,
    _tokenOut: string,
    _maxSteps: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], string[], string[]] & {
      amounts: BigNumber[];
      adapters: string[];
      path: string[];
    }
  >;

  "findBestPath(uint256,address,address,uint256)"(
    _amountIn: BigNumberish,
    _tokenIn: string,
    _tokenOut: string,
    _maxSteps: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], string[], string[]] & {
      amounts: BigNumber[];
      adapters: string[];
      path: string[];
    }
  >;

  findBestPathWithGas(
    _amountIn: BigNumberish,
    _tokenIn: string,
    _tokenOut: string,
    _maxSteps: BigNumberish,
    _gasPrice: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], string[], string[], BigNumber] & {
      amounts: BigNumber[];
      adapters: string[];
      path: string[];
      gasEstimate: BigNumber;
    }
  >;

  "findBestPathWithGas(uint256,address,address,uint256,uint256)"(
    _amountIn: BigNumberish,
    _tokenIn: string,
    _tokenOut: string,
    _maxSteps: BigNumberish,
    _gasPrice: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber[], string[], string[], BigNumber] & {
      amounts: BigNumber[];
      adapters: string[];
      path: string[];
      gasEstimate: BigNumber;
    }
  >;

  owner(overrides?: CallOverrides): Promise<string>;

  "owner()"(overrides?: CallOverrides): Promise<string>;

  queryAdapter(
    _amountIn: BigNumberish,
    _tokenIn: string,
    _tokenOut: string,
    _index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "queryAdapter(uint256,address,address,uint8)"(
    _amountIn: BigNumberish,
    _tokenIn: string,
    _tokenOut: string,
    _index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "queryNoSplit(uint256,address,address,uint8[])"(
    _amountIn: BigNumberish,
    _tokenIn: string,
    _tokenOut: string,
    _options: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<
    [string, string, string, BigNumber] & {
      adapter: string;
      tokenIn: string;
      tokenOut: string;
      amountOut: BigNumber;
    }
  >;

  "queryNoSplit(uint256,address,address)"(
    _amountIn: BigNumberish,
    _tokenIn: string,
    _tokenOut: string,
    overrides?: CallOverrides
  ): Promise<
    [string, string, string, BigNumber] & {
      adapter: string;
      tokenIn: string;
      tokenOut: string;
      amountOut: BigNumber;
    }
  >;

  recoverAVAX(
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "recoverAVAX(uint256)"(
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  recoverERC20(
    _tokenAddress: string,
    _tokenAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "recoverERC20(address,uint256)"(
    _tokenAddress: string,
    _tokenAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "renounceOwnership()"(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setAdapters(
    _adapters: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "setAdapters(address[])"(
    _adapters: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setFeeClaimer(
    _claimer: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "setFeeClaimer(address)"(
    _claimer: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setMinFee(
    _fee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "setMinFee(uint256)"(
    _fee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setTrustedTokens(
    _trustedTokens: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "setTrustedTokens(address[])"(
    _trustedTokens: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapNoSplit(
    _trade: {
      amountIn: BigNumberish;
      amountOut: BigNumberish;
      path: string[];
      adapters: string[];
    },
    _to: string,
    _fee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "swapNoSplit((uint256,uint256,address[],address[]),address,uint256)"(
    _trade: {
      amountIn: BigNumberish;
      amountOut: BigNumberish;
      path: string[];
      adapters: string[];
    },
    _to: string,
    _fee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapNoSplitFromAVAX(
    _trade: {
      amountIn: BigNumberish;
      amountOut: BigNumberish;
      path: string[];
      adapters: string[];
    },
    _to: string,
    _fee: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "swapNoSplitFromAVAX((uint256,uint256,address[],address[]),address,uint256)"(
    _trade: {
      amountIn: BigNumberish;
      amountOut: BigNumberish;
      path: string[];
      adapters: string[];
    },
    _to: string,
    _fee: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapNoSplitToAVAX(
    _trade: {
      amountIn: BigNumberish;
      amountOut: BigNumberish;
      path: string[];
      adapters: string[];
    },
    _to: string,
    _fee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "swapNoSplitToAVAX((uint256,uint256,address[],address[]),address,uint256)"(
    _trade: {
      amountIn: BigNumberish;
      amountOut: BigNumberish;
      path: string[];
      adapters: string[];
    },
    _to: string,
    _fee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapNoSplitToAVAXWithPermit(
    _trade: {
      amountIn: BigNumberish;
      amountOut: BigNumberish;
      path: string[];
      adapters: string[];
    },
    _to: string,
    _fee: BigNumberish,
    _deadline: BigNumberish,
    _v: BigNumberish,
    _r: BytesLike,
    _s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "swapNoSplitToAVAXWithPermit((uint256,uint256,address[],address[]),address,uint256,uint256,uint8,bytes32,bytes32)"(
    _trade: {
      amountIn: BigNumberish;
      amountOut: BigNumberish;
      path: string[];
      adapters: string[];
    },
    _to: string,
    _fee: BigNumberish,
    _deadline: BigNumberish,
    _v: BigNumberish,
    _r: BytesLike,
    _s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapNoSplitWithPermit(
    _trade: {
      amountIn: BigNumberish;
      amountOut: BigNumberish;
      path: string[];
      adapters: string[];
    },
    _to: string,
    _fee: BigNumberish,
    _deadline: BigNumberish,
    _v: BigNumberish,
    _r: BytesLike,
    _s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "swapNoSplitWithPermit((uint256,uint256,address[],address[]),address,uint256,uint256,uint8,bytes32,bytes32)"(
    _trade: {
      amountIn: BigNumberish;
      amountOut: BigNumberish;
      path: string[];
      adapters: string[];
    },
    _to: string,
    _fee: BigNumberish,
    _deadline: BigNumberish,
    _v: BigNumberish,
    _r: BytesLike,
    _s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  "transferOwnership(address)"(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  trustedTokensCount(overrides?: CallOverrides): Promise<BigNumber>;

  "trustedTokensCount()"(overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    ADAPTERS(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    "ADAPTERS(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    AVAX(overrides?: CallOverrides): Promise<string>;

    "AVAX()"(overrides?: CallOverrides): Promise<string>;

    FEE_CLAIMER(overrides?: CallOverrides): Promise<string>;

    "FEE_CLAIMER()"(overrides?: CallOverrides): Promise<string>;

    FEE_DENOMINATOR(overrides?: CallOverrides): Promise<BigNumber>;

    "FEE_DENOMINATOR()"(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_FEE(overrides?: CallOverrides): Promise<BigNumber>;

    "MIN_FEE()"(overrides?: CallOverrides): Promise<BigNumber>;

    NAME(overrides?: CallOverrides): Promise<string>;

    "NAME()"(overrides?: CallOverrides): Promise<string>;

    TRUSTED_TOKENS(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    "TRUSTED_TOKENS(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    WAVAX(overrides?: CallOverrides): Promise<string>;

    "WAVAX()"(overrides?: CallOverrides): Promise<string>;

    adaptersCount(overrides?: CallOverrides): Promise<BigNumber>;

    "adaptersCount()"(overrides?: CallOverrides): Promise<BigNumber>;

    findBestPath(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], string[], string[]] & {
        amounts: BigNumber[];
        adapters: string[];
        path: string[];
      }
    >;

    "findBestPath(uint256,address,address,uint256)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], string[], string[]] & {
        amounts: BigNumber[];
        adapters: string[];
        path: string[];
      }
    >;

    findBestPathWithGas(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      _gasPrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], string[], string[], BigNumber] & {
        amounts: BigNumber[];
        adapters: string[];
        path: string[];
        gasEstimate: BigNumber;
      }
    >;

    "findBestPathWithGas(uint256,address,address,uint256,uint256)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      _gasPrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], string[], string[], BigNumber] & {
        amounts: BigNumber[];
        adapters: string[];
        path: string[];
        gasEstimate: BigNumber;
      }
    >;

    owner(overrides?: CallOverrides): Promise<string>;

    "owner()"(overrides?: CallOverrides): Promise<string>;

    queryAdapter(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "queryAdapter(uint256,address,address,uint8)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "queryNoSplit(uint256,address,address,uint8[])"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _options: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<
      [string, string, string, BigNumber] & {
        adapter: string;
        tokenIn: string;
        tokenOut: string;
        amountOut: BigNumber;
      }
    >;

    "queryNoSplit(uint256,address,address)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      overrides?: CallOverrides
    ): Promise<
      [string, string, string, BigNumber] & {
        adapter: string;
        tokenIn: string;
        tokenOut: string;
        amountOut: BigNumber;
      }
    >;

    recoverAVAX(
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "recoverAVAX(uint256)"(
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    recoverERC20(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "recoverERC20(address,uint256)"(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    "renounceOwnership()"(overrides?: CallOverrides): Promise<void>;

    setAdapters(_adapters: string[], overrides?: CallOverrides): Promise<void>;

    "setAdapters(address[])"(
      _adapters: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    setFeeClaimer(_claimer: string, overrides?: CallOverrides): Promise<void>;

    "setFeeClaimer(address)"(
      _claimer: string,
      overrides?: CallOverrides
    ): Promise<void>;

    setMinFee(_fee: BigNumberish, overrides?: CallOverrides): Promise<void>;

    "setMinFee(uint256)"(
      _fee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setTrustedTokens(
      _trustedTokens: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    "setTrustedTokens(address[])"(
      _trustedTokens: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    swapNoSplit(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "swapNoSplit((uint256,uint256,address[],address[]),address,uint256)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    swapNoSplitFromAVAX(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "swapNoSplitFromAVAX((uint256,uint256,address[],address[]),address,uint256)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    swapNoSplitToAVAX(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "swapNoSplitToAVAX((uint256,uint256,address[],address[]),address,uint256)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    swapNoSplitToAVAXWithPermit(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    "swapNoSplitToAVAXWithPermit((uint256,uint256,address[],address[]),address,uint256,uint256,uint8,bytes32,bytes32)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    swapNoSplitWithPermit(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    "swapNoSplitWithPermit((uint256,uint256,address[],address[]),address,uint256,uint256,uint8,bytes32,bytes32)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    "transferOwnership(address)"(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    trustedTokensCount(overrides?: CallOverrides): Promise<BigNumber>;

    "trustedTokensCount()"(overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {
    OwnershipTransferred(
      previousOwner: string | null,
      newOwner: string | null
    ): TypedEventFilter<
      [string, string],
      { previousOwner: string; newOwner: string }
    >;

    Recovered(
      _asset: string | null,
      amount: null
    ): TypedEventFilter<
      [string, BigNumber],
      { _asset: string; amount: BigNumber }
    >;

    UpdatedAdapters(
      _newAdapters: null
    ): TypedEventFilter<[string[]], { _newAdapters: string[] }>;

    UpdatedFeeClaimer(
      _oldFeeClaimer: null,
      _newFeeClaimer: null
    ): TypedEventFilter<
      [string, string],
      { _oldFeeClaimer: string; _newFeeClaimer: string }
    >;

    UpdatedMinFee(
      _oldMinFee: null,
      _newMinFee: null
    ): TypedEventFilter<
      [BigNumber, BigNumber],
      { _oldMinFee: BigNumber; _newMinFee: BigNumber }
    >;

    UpdatedTrustedTokens(
      _newTrustedTokens: null
    ): TypedEventFilter<[string[]], { _newTrustedTokens: string[] }>;

    YakSwap(
      _tokenIn: string | null,
      _tokenOut: string | null,
      _amountIn: null,
      _amountOut: null
    ): TypedEventFilter<
      [string, string, BigNumber, BigNumber],
      {
        _tokenIn: string;
        _tokenOut: string;
        _amountIn: BigNumber;
        _amountOut: BigNumber;
      }
    >;
  };

  estimateGas: {
    ADAPTERS(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    "ADAPTERS(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    AVAX(overrides?: CallOverrides): Promise<BigNumber>;

    "AVAX()"(overrides?: CallOverrides): Promise<BigNumber>;

    FEE_CLAIMER(overrides?: CallOverrides): Promise<BigNumber>;

    "FEE_CLAIMER()"(overrides?: CallOverrides): Promise<BigNumber>;

    FEE_DENOMINATOR(overrides?: CallOverrides): Promise<BigNumber>;

    "FEE_DENOMINATOR()"(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_FEE(overrides?: CallOverrides): Promise<BigNumber>;

    "MIN_FEE()"(overrides?: CallOverrides): Promise<BigNumber>;

    NAME(overrides?: CallOverrides): Promise<BigNumber>;

    "NAME()"(overrides?: CallOverrides): Promise<BigNumber>;

    TRUSTED_TOKENS(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "TRUSTED_TOKENS(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    WAVAX(overrides?: CallOverrides): Promise<BigNumber>;

    "WAVAX()"(overrides?: CallOverrides): Promise<BigNumber>;

    adaptersCount(overrides?: CallOverrides): Promise<BigNumber>;

    "adaptersCount()"(overrides?: CallOverrides): Promise<BigNumber>;

    findBestPath(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "findBestPath(uint256,address,address,uint256)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    findBestPathWithGas(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      _gasPrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "findBestPathWithGas(uint256,address,address,uint256,uint256)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      _gasPrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    "owner()"(overrides?: CallOverrides): Promise<BigNumber>;

    queryAdapter(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "queryAdapter(uint256,address,address,uint8)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "queryNoSplit(uint256,address,address,uint8[])"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _options: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "queryNoSplit(uint256,address,address)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    recoverAVAX(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "recoverAVAX(uint256)"(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    recoverERC20(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "recoverERC20(address,uint256)"(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "renounceOwnership()"(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setAdapters(
      _adapters: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "setAdapters(address[])"(
      _adapters: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setFeeClaimer(
      _claimer: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "setFeeClaimer(address)"(
      _claimer: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setMinFee(
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "setMinFee(uint256)"(
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setTrustedTokens(
      _trustedTokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "setTrustedTokens(address[])"(
      _trustedTokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapNoSplit(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "swapNoSplit((uint256,uint256,address[],address[]),address,uint256)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapNoSplitFromAVAX(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "swapNoSplitFromAVAX((uint256,uint256,address[],address[]),address,uint256)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapNoSplitToAVAX(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "swapNoSplitToAVAX((uint256,uint256,address[],address[]),address,uint256)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapNoSplitToAVAXWithPermit(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "swapNoSplitToAVAXWithPermit((uint256,uint256,address[],address[]),address,uint256,uint256,uint8,bytes32,bytes32)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapNoSplitWithPermit(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "swapNoSplitWithPermit((uint256,uint256,address[],address[]),address,uint256,uint256,uint8,bytes32,bytes32)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    "transferOwnership(address)"(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    trustedTokensCount(overrides?: CallOverrides): Promise<BigNumber>;

    "trustedTokensCount()"(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    ADAPTERS(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "ADAPTERS(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    AVAX(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "AVAX()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    FEE_CLAIMER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "FEE_CLAIMER()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    FEE_DENOMINATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "FEE_DENOMINATOR()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    MIN_FEE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "MIN_FEE()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NAME(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "NAME()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    TRUSTED_TOKENS(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "TRUSTED_TOKENS(uint256)"(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    WAVAX(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "WAVAX()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    adaptersCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "adaptersCount()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    findBestPath(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "findBestPath(uint256,address,address,uint256)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    findBestPathWithGas(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      _gasPrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "findBestPathWithGas(uint256,address,address,uint256,uint256)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      _gasPrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    "owner()"(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    queryAdapter(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "queryAdapter(uint256,address,address,uint8)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "queryNoSplit(uint256,address,address,uint8[])"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _options: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "queryNoSplit(uint256,address,address)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    recoverAVAX(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "recoverAVAX(uint256)"(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    recoverERC20(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "recoverERC20(address,uint256)"(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "renounceOwnership()"(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setAdapters(
      _adapters: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "setAdapters(address[])"(
      _adapters: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setFeeClaimer(
      _claimer: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "setFeeClaimer(address)"(
      _claimer: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setMinFee(
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "setMinFee(uint256)"(
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setTrustedTokens(
      _trustedTokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "setTrustedTokens(address[])"(
      _trustedTokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapNoSplit(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "swapNoSplit((uint256,uint256,address[],address[]),address,uint256)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapNoSplitFromAVAX(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "swapNoSplitFromAVAX((uint256,uint256,address[],address[]),address,uint256)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapNoSplitToAVAX(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "swapNoSplitToAVAX((uint256,uint256,address[],address[]),address,uint256)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapNoSplitToAVAXWithPermit(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "swapNoSplitToAVAXWithPermit((uint256,uint256,address[],address[]),address,uint256,uint256,uint8,bytes32,bytes32)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapNoSplitWithPermit(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "swapNoSplitWithPermit((uint256,uint256,address[],address[]),address,uint256,uint256,uint8,bytes32,bytes32)"(
      _trade: {
        amountIn: BigNumberish;
        amountOut: BigNumberish;
        path: string[];
        adapters: string[];
      },
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    "transferOwnership(address)"(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    trustedTokensCount(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "trustedTokensCount()"(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
