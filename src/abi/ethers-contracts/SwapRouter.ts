/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";

export declare namespace YakRouter {
  export type FormattedOfferStruct = {
    amounts: BigNumberish[];
    adapters: string[];
    path: string[];
  };

  export type FormattedOfferStructOutput = [BigNumber[], string[], string[]] & {
    amounts: BigNumber[];
    adapters: string[];
    path: string[];
  };

  export type FormattedOfferWithGasStruct = {
    amounts: BigNumberish[];
    adapters: string[];
    path: string[];
    gasEstimate: BigNumberish;
  };

  export type FormattedOfferWithGasStructOutput = [
    BigNumber[],
    string[],
    string[],
    BigNumber
  ] & {
    amounts: BigNumber[];
    adapters: string[];
    path: string[];
    gasEstimate: BigNumber;
  };

  export type QueryStruct = {
    adapter: string;
    tokenIn: string;
    tokenOut: string;
    amountOut: BigNumberish;
  };

  export type QueryStructOutput = [string, string, string, BigNumber] & {
    adapter: string;
    tokenIn: string;
    tokenOut: string;
    amountOut: BigNumber;
  };

  export type TradeStruct = {
    amountIn: BigNumberish;
    amountOut: BigNumberish;
    path: string[];
    adapters: string[];
  };

  export type TradeStructOutput = [BigNumber, BigNumber, string[], string[]] & {
    amountIn: BigNumber;
    amountOut: BigNumber;
    path: string[];
    adapters: string[];
  };
}

export interface SwapRouterInterface extends utils.Interface {
  contractName: "SwapRouter";
  functions: {
    "ADAPTERS(uint256)": FunctionFragment;
    "AVAX()": FunctionFragment;
    "FEE_CLAIMER()": FunctionFragment;
    "FEE_DENOMINATOR()": FunctionFragment;
    "MIN_FEE()": FunctionFragment;
    "NAME()": FunctionFragment;
    "TRUSTED_TOKENS(uint256)": FunctionFragment;
    "WAVAX()": FunctionFragment;
    "adaptersCount()": FunctionFragment;
    "findBestPath(uint256,address,address,uint256)": FunctionFragment;
    "findBestPathWithGas(uint256,address,address,uint256,uint256)": FunctionFragment;
    "owner()": FunctionFragment;
    "queryAdapter(uint256,address,address,uint8)": FunctionFragment;
    "queryNoSplit(uint256,address,address,uint8[])": FunctionFragment;
    "recoverAVAX(uint256)": FunctionFragment;
    "recoverERC20(address,uint256)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "setAdapters(address[])": FunctionFragment;
    "setFeeClaimer(address)": FunctionFragment;
    "setMinFee(uint256)": FunctionFragment;
    "setTrustedTokens(address[])": FunctionFragment;
    "swapNoSplit((uint256,uint256,address[],address[]),address,uint256)": FunctionFragment;
    "swapNoSplitFromAVAX((uint256,uint256,address[],address[]),address,uint256)": FunctionFragment;
    "swapNoSplitToAVAX((uint256,uint256,address[],address[]),address,uint256)": FunctionFragment;
    "swapNoSplitToAVAXWithPermit((uint256,uint256,address[],address[]),address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
    "swapNoSplitWithPermit((uint256,uint256,address[],address[]),address,uint256,uint256,uint8,bytes32,bytes32)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "trustedTokensCount()": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "ADAPTERS",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "AVAX", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "FEE_CLAIMER",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "FEE_DENOMINATOR",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "MIN_FEE", values?: undefined): string;
  encodeFunctionData(functionFragment: "NAME", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "TRUSTED_TOKENS",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "WAVAX", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "adaptersCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "findBestPath",
    values: [BigNumberish, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "findBestPathWithGas",
    values: [BigNumberish, string, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "queryAdapter",
    values: [BigNumberish, string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "queryNoSplit",
    values: [BigNumberish, string, string, BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "recoverAVAX",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "recoverERC20",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setAdapters",
    values: [string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "setFeeClaimer",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setMinFee",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setTrustedTokens",
    values: [string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "swapNoSplit",
    values: [YakRouter.TradeStruct, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "swapNoSplitFromAVAX",
    values: [YakRouter.TradeStruct, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "swapNoSplitToAVAX",
    values: [YakRouter.TradeStruct, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "swapNoSplitToAVAXWithPermit",
    values: [
      YakRouter.TradeStruct,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "swapNoSplitWithPermit",
    values: [
      YakRouter.TradeStruct,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "trustedTokensCount",
    values?: undefined
  ): string;

  decodeFunctionResult(functionFragment: "ADAPTERS", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "AVAX", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "FEE_CLAIMER",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "FEE_DENOMINATOR",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "MIN_FEE", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "NAME", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "TRUSTED_TOKENS",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "WAVAX", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "adaptersCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "findBestPath",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "findBestPathWithGas",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "queryAdapter",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "queryNoSplit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "recoverAVAX",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "recoverERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAdapters",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFeeClaimer",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setMinFee", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setTrustedTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapNoSplit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapNoSplitFromAVAX",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapNoSplitToAVAX",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapNoSplitToAVAXWithPermit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "swapNoSplitWithPermit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "trustedTokensCount",
    data: BytesLike
  ): Result;

  events: {
    "OwnershipTransferred(address,address)": EventFragment;
    "Recovered(address,uint256)": EventFragment;
    "UpdatedAdapters(address[])": EventFragment;
    "UpdatedFeeClaimer(address,address)": EventFragment;
    "UpdatedMinFee(uint256,uint256)": EventFragment;
    "UpdatedTrustedTokens(address[])": EventFragment;
    "YakSwap(address,address,uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "Recovered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdatedAdapters"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdatedFeeClaimer"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdatedMinFee"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UpdatedTrustedTokens"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "YakSwap"): EventFragment;
}

export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  { previousOwner: string; newOwner: string }
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export type RecoveredEvent = TypedEvent<
  [string, BigNumber],
  { _asset: string; amount: BigNumber }
>;

export type RecoveredEventFilter = TypedEventFilter<RecoveredEvent>;

export type UpdatedAdaptersEvent = TypedEvent<
  [string[]],
  { _newAdapters: string[] }
>;

export type UpdatedAdaptersEventFilter = TypedEventFilter<UpdatedAdaptersEvent>;

export type UpdatedFeeClaimerEvent = TypedEvent<
  [string, string],
  { _oldFeeClaimer: string; _newFeeClaimer: string }
>;

export type UpdatedFeeClaimerEventFilter =
  TypedEventFilter<UpdatedFeeClaimerEvent>;

export type UpdatedMinFeeEvent = TypedEvent<
  [BigNumber, BigNumber],
  { _oldMinFee: BigNumber; _newMinFee: BigNumber }
>;

export type UpdatedMinFeeEventFilter = TypedEventFilter<UpdatedMinFeeEvent>;

export type UpdatedTrustedTokensEvent = TypedEvent<
  [string[]],
  { _newTrustedTokens: string[] }
>;

export type UpdatedTrustedTokensEventFilter =
  TypedEventFilter<UpdatedTrustedTokensEvent>;

export type YakSwapEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  {
    _tokenIn: string;
    _tokenOut: string;
    _amountIn: BigNumber;
    _amountOut: BigNumber;
  }
>;

export type YakSwapEventFilter = TypedEventFilter<YakSwapEvent>;

export interface SwapRouter extends BaseContract {
  contractName: "SwapRouter";
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: SwapRouterInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    ADAPTERS(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;

    AVAX(overrides?: CallOverrides): Promise<[string]>;

    FEE_CLAIMER(overrides?: CallOverrides): Promise<[string]>;

    FEE_DENOMINATOR(overrides?: CallOverrides): Promise<[BigNumber]>;

    MIN_FEE(overrides?: CallOverrides): Promise<[BigNumber]>;

    NAME(overrides?: CallOverrides): Promise<[string]>;

    TRUSTED_TOKENS(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string]>;

    WAVAX(overrides?: CallOverrides): Promise<[string]>;

    adaptersCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    findBestPath(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[YakRouter.FormattedOfferStructOutput]>;

    findBestPathWithGas(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      _gasPrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[YakRouter.FormattedOfferWithGasStructOutput]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    queryAdapter(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    "queryNoSplit(uint256,address,address,uint8[])"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _options: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<[YakRouter.QueryStructOutput]>;

    "queryNoSplit(uint256,address,address)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      overrides?: CallOverrides
    ): Promise<[YakRouter.QueryStructOutput]>;

    recoverAVAX(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    recoverERC20(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setAdapters(
      _adapters: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setFeeClaimer(
      _claimer: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setMinFee(
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setTrustedTokens(
      _trustedTokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapNoSplit(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapNoSplitFromAVAX(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapNoSplitToAVAX(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapNoSplitToAVAXWithPermit(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    swapNoSplitWithPermit(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    trustedTokensCount(overrides?: CallOverrides): Promise<[BigNumber]>;
  };

  ADAPTERS(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

  AVAX(overrides?: CallOverrides): Promise<string>;

  FEE_CLAIMER(overrides?: CallOverrides): Promise<string>;

  FEE_DENOMINATOR(overrides?: CallOverrides): Promise<BigNumber>;

  MIN_FEE(overrides?: CallOverrides): Promise<BigNumber>;

  NAME(overrides?: CallOverrides): Promise<string>;

  TRUSTED_TOKENS(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  WAVAX(overrides?: CallOverrides): Promise<string>;

  adaptersCount(overrides?: CallOverrides): Promise<BigNumber>;

  findBestPath(
    _amountIn: BigNumberish,
    _tokenIn: string,
    _tokenOut: string,
    _maxSteps: BigNumberish,
    overrides?: CallOverrides
  ): Promise<YakRouter.FormattedOfferStructOutput>;

  findBestPathWithGas(
    _amountIn: BigNumberish,
    _tokenIn: string,
    _tokenOut: string,
    _maxSteps: BigNumberish,
    _gasPrice: BigNumberish,
    overrides?: CallOverrides
  ): Promise<YakRouter.FormattedOfferWithGasStructOutput>;

  owner(overrides?: CallOverrides): Promise<string>;

  queryAdapter(
    _amountIn: BigNumberish,
    _tokenIn: string,
    _tokenOut: string,
    _index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  "queryNoSplit(uint256,address,address,uint8[])"(
    _amountIn: BigNumberish,
    _tokenIn: string,
    _tokenOut: string,
    _options: BigNumberish[],
    overrides?: CallOverrides
  ): Promise<YakRouter.QueryStructOutput>;

  "queryNoSplit(uint256,address,address)"(
    _amountIn: BigNumberish,
    _tokenIn: string,
    _tokenOut: string,
    overrides?: CallOverrides
  ): Promise<YakRouter.QueryStructOutput>;

  recoverAVAX(
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  recoverERC20(
    _tokenAddress: string,
    _tokenAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setAdapters(
    _adapters: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setFeeClaimer(
    _claimer: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setMinFee(
    _fee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setTrustedTokens(
    _trustedTokens: string[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapNoSplit(
    _trade: YakRouter.TradeStruct,
    _to: string,
    _fee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapNoSplitFromAVAX(
    _trade: YakRouter.TradeStruct,
    _to: string,
    _fee: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapNoSplitToAVAX(
    _trade: YakRouter.TradeStruct,
    _to: string,
    _fee: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapNoSplitToAVAXWithPermit(
    _trade: YakRouter.TradeStruct,
    _to: string,
    _fee: BigNumberish,
    _deadline: BigNumberish,
    _v: BigNumberish,
    _r: BytesLike,
    _s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  swapNoSplitWithPermit(
    _trade: YakRouter.TradeStruct,
    _to: string,
    _fee: BigNumberish,
    _deadline: BigNumberish,
    _v: BigNumberish,
    _r: BytesLike,
    _s: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  trustedTokensCount(overrides?: CallOverrides): Promise<BigNumber>;

  callStatic: {
    ADAPTERS(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;

    AVAX(overrides?: CallOverrides): Promise<string>;

    FEE_CLAIMER(overrides?: CallOverrides): Promise<string>;

    FEE_DENOMINATOR(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_FEE(overrides?: CallOverrides): Promise<BigNumber>;

    NAME(overrides?: CallOverrides): Promise<string>;

    TRUSTED_TOKENS(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    WAVAX(overrides?: CallOverrides): Promise<string>;

    adaptersCount(overrides?: CallOverrides): Promise<BigNumber>;

    findBestPath(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      overrides?: CallOverrides
    ): Promise<YakRouter.FormattedOfferStructOutput>;

    findBestPathWithGas(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      _gasPrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<YakRouter.FormattedOfferWithGasStructOutput>;

    owner(overrides?: CallOverrides): Promise<string>;

    queryAdapter(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "queryNoSplit(uint256,address,address,uint8[])"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _options: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<YakRouter.QueryStructOutput>;

    "queryNoSplit(uint256,address,address)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      overrides?: CallOverrides
    ): Promise<YakRouter.QueryStructOutput>;

    recoverAVAX(
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    recoverERC20(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    setAdapters(_adapters: string[], overrides?: CallOverrides): Promise<void>;

    setFeeClaimer(_claimer: string, overrides?: CallOverrides): Promise<void>;

    setMinFee(_fee: BigNumberish, overrides?: CallOverrides): Promise<void>;

    setTrustedTokens(
      _trustedTokens: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    swapNoSplit(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    swapNoSplitFromAVAX(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    swapNoSplitToAVAX(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    swapNoSplitToAVAXWithPermit(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    swapNoSplitWithPermit(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    trustedTokensCount(overrides?: CallOverrides): Promise<BigNumber>;
  };

  filters: {
    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "Recovered(address,uint256)"(
      _asset?: string | null,
      amount?: null
    ): RecoveredEventFilter;
    Recovered(_asset?: string | null, amount?: null): RecoveredEventFilter;

    "UpdatedAdapters(address[])"(
      _newAdapters?: null
    ): UpdatedAdaptersEventFilter;
    UpdatedAdapters(_newAdapters?: null): UpdatedAdaptersEventFilter;

    "UpdatedFeeClaimer(address,address)"(
      _oldFeeClaimer?: null,
      _newFeeClaimer?: null
    ): UpdatedFeeClaimerEventFilter;
    UpdatedFeeClaimer(
      _oldFeeClaimer?: null,
      _newFeeClaimer?: null
    ): UpdatedFeeClaimerEventFilter;

    "UpdatedMinFee(uint256,uint256)"(
      _oldMinFee?: null,
      _newMinFee?: null
    ): UpdatedMinFeeEventFilter;
    UpdatedMinFee(
      _oldMinFee?: null,
      _newMinFee?: null
    ): UpdatedMinFeeEventFilter;

    "UpdatedTrustedTokens(address[])"(
      _newTrustedTokens?: null
    ): UpdatedTrustedTokensEventFilter;
    UpdatedTrustedTokens(
      _newTrustedTokens?: null
    ): UpdatedTrustedTokensEventFilter;

    "YakSwap(address,address,uint256,uint256)"(
      _tokenIn?: string | null,
      _tokenOut?: string | null,
      _amountIn?: null,
      _amountOut?: null
    ): YakSwapEventFilter;
    YakSwap(
      _tokenIn?: string | null,
      _tokenOut?: string | null,
      _amountIn?: null,
      _amountOut?: null
    ): YakSwapEventFilter;
  };

  estimateGas: {
    ADAPTERS(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    AVAX(overrides?: CallOverrides): Promise<BigNumber>;

    FEE_CLAIMER(overrides?: CallOverrides): Promise<BigNumber>;

    FEE_DENOMINATOR(overrides?: CallOverrides): Promise<BigNumber>;

    MIN_FEE(overrides?: CallOverrides): Promise<BigNumber>;

    NAME(overrides?: CallOverrides): Promise<BigNumber>;

    TRUSTED_TOKENS(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    WAVAX(overrides?: CallOverrides): Promise<BigNumber>;

    adaptersCount(overrides?: CallOverrides): Promise<BigNumber>;

    findBestPath(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    findBestPathWithGas(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      _gasPrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    queryAdapter(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "queryNoSplit(uint256,address,address,uint8[])"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _options: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    "queryNoSplit(uint256,address,address)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    recoverAVAX(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    recoverERC20(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setAdapters(
      _adapters: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setFeeClaimer(
      _claimer: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setMinFee(
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setTrustedTokens(
      _trustedTokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapNoSplit(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapNoSplitFromAVAX(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapNoSplitToAVAX(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapNoSplitToAVAXWithPermit(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    swapNoSplitWithPermit(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    trustedTokensCount(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    ADAPTERS(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    AVAX(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    FEE_CLAIMER(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    FEE_DENOMINATOR(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    MIN_FEE(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    NAME(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    TRUSTED_TOKENS(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    WAVAX(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    adaptersCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    findBestPath(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    findBestPathWithGas(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _maxSteps: BigNumberish,
      _gasPrice: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    queryAdapter(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "queryNoSplit(uint256,address,address,uint8[])"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      _options: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    "queryNoSplit(uint256,address,address)"(
      _amountIn: BigNumberish,
      _tokenIn: string,
      _tokenOut: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    recoverAVAX(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    recoverERC20(
      _tokenAddress: string,
      _tokenAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setAdapters(
      _adapters: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setFeeClaimer(
      _claimer: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setMinFee(
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setTrustedTokens(
      _trustedTokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapNoSplit(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapNoSplitFromAVAX(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapNoSplitToAVAX(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapNoSplitToAVAXWithPermit(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    swapNoSplitWithPermit(
      _trade: YakRouter.TradeStruct,
      _to: string,
      _fee: BigNumberish,
      _deadline: BigNumberish,
      _v: BigNumberish,
      _r: BytesLike,
      _s: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    trustedTokensCount(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
