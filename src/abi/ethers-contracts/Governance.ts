/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";

export declare namespace Governance {
  export type ProposalExecutionContextStruct = {
    label: string;
    target: string;
    value: BigNumberish;
    data: BytesLike;
  };

  export type ProposalExecutionContextStructOutput = [
    string,
    string,
    BigNumber,
    string
  ] & { label: string; target: string; value: BigNumber; data: string };

  export type ProposalExecutionContextListStruct = {
    length: BigNumberish;
    contexts: Governance.ProposalExecutionContextStruct[];
  };

  export type ProposalExecutionContextListStructOutput = [
    BigNumber,
    Governance.ProposalExecutionContextStructOutput[]
  ] & {
    length: BigNumber;
    contexts: Governance.ProposalExecutionContextStructOutput[];
  };

  export type ProposalStruct = {
    title: string;
    metadata: string;
    proposer: string;
    executor: string;
    startTime: BigNumberish;
    votingPeriod: BigNumberish;
    quorumVotes: BigNumberish;
    executionDelay: BigNumberish;
    votes: BigNumberish[];
    isBoolean: boolean;
    executionContexts: Governance.ProposalExecutionContextListStruct;
  };

  export type ProposalStructOutput = [
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber[],
    boolean,
    Governance.ProposalExecutionContextListStructOutput
  ] & {
    title: string;
    metadata: string;
    proposer: string;
    executor: string;
    startTime: BigNumber;
    votingPeriod: BigNumber;
    quorumVotes: BigNumber;
    executionDelay: BigNumber;
    votes: BigNumber[];
    isBoolean: boolean;
    executionContexts: Governance.ProposalExecutionContextListStructOutput;
  };

  export type ReceiptStruct = {
    hasVoted: boolean;
    support: BigNumberish;
    votes: BigNumberish;
  };

  export type ReceiptStructOutput = [boolean, BigNumber, BigNumber] & {
    hasVoted: boolean;
    support: BigNumber;
    votes: BigNumber;
  };
}

export interface GovernanceInterface extends utils.Interface {
  contractName: "Governance";
  functions: {
    "EXECUTION_DELAY_MAXIMUM()": FunctionFragment;
    "EXECUTION_DELAY_MINIMUM()": FunctionFragment;
    "EXPIRATION_PERIOD()": FunctionFragment;
    "PROPOSAL_THRESHOLD_MAXIMUM()": FunctionFragment;
    "PROPOSAL_THRESHOLD_MINIMUM()": FunctionFragment;
    "QUORUM_VOTES_MAXIMUM()": FunctionFragment;
    "QUORUM_VOTES_MINIMUM()": FunctionFragment;
    "VOTING_PERIOD_MAXIMUM()": FunctionFragment;
    "VOTING_PERIOD_MINIMUM()": FunctionFragment;
    "constructProposalExecutionContexts(string[],address[],uint256[],bytes[])": FunctionFragment;
    "constructProposalMetadata(string,string,uint256,bool)": FunctionFragment;
    "execute(uint256)": FunctionFragment;
    "executionDelay()": FunctionFragment;
    "getProposalVotes(uint256)": FunctionFragment;
    "getReceipt(uint256,address)": FunctionFragment;
    "lastProposalByAddress(address)": FunctionFragment;
    "minimumVotingPeriod()": FunctionFragment;
    "owner()": FunctionFragment;
    "proposalCount()": FunctionFragment;
    "proposalThreshold()": FunctionFragment;
    "proposals(uint256)": FunctionFragment;
    "propose((string,string,address,address,uint256,uint256,uint256,uint256,uint256[],bool,(uint256,(string,address,uint256,bytes)[])),(uint256,(string,address,uint256,bytes)[]))": FunctionFragment;
    "quorumVotes()": FunctionFragment;
    "receipts(uint256,address)": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "sAXIAL()": FunctionFragment;
    "setExecutionDelay(uint256)": FunctionFragment;
    "setMinimumVotingPeriod(uint256)": FunctionFragment;
    "setProposalThreshold(uint256)": FunctionFragment;
    "setQuorumVotes(uint256)": FunctionFragment;
    "state(uint256)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "vote(uint256,uint256)": FunctionFragment;
  };

  encodeFunctionData(
    functionFragment: "EXECUTION_DELAY_MAXIMUM",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "EXECUTION_DELAY_MINIMUM",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "EXPIRATION_PERIOD",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PROPOSAL_THRESHOLD_MAXIMUM",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "PROPOSAL_THRESHOLD_MINIMUM",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "QUORUM_VOTES_MAXIMUM",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "QUORUM_VOTES_MINIMUM",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "VOTING_PERIOD_MAXIMUM",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "VOTING_PERIOD_MINIMUM",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "constructProposalExecutionContexts",
    values: [string[], string[], BigNumberish[], BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "constructProposalMetadata",
    values: [string, string, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "execute",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executionDelay",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getProposalVotes",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getReceipt",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "lastProposalByAddress",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "minimumVotingPeriod",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "proposalCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "proposalThreshold",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "proposals",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "propose",
    values: [
      Governance.ProposalStruct,
      Governance.ProposalExecutionContextListStruct
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "quorumVotes",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "receipts",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "sAXIAL", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setExecutionDelay",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setMinimumVotingPeriod",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setProposalThreshold",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setQuorumVotes",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "state", values: [BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "vote",
    values: [BigNumberish, BigNumberish]
  ): string;

  decodeFunctionResult(
    functionFragment: "EXECUTION_DELAY_MAXIMUM",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "EXECUTION_DELAY_MINIMUM",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "EXPIRATION_PERIOD",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PROPOSAL_THRESHOLD_MAXIMUM",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "PROPOSAL_THRESHOLD_MINIMUM",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "QUORUM_VOTES_MAXIMUM",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "QUORUM_VOTES_MINIMUM",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "VOTING_PERIOD_MAXIMUM",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "VOTING_PERIOD_MINIMUM",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "constructProposalExecutionContexts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "constructProposalMetadata",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "execute", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executionDelay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposalVotes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getReceipt", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "lastProposalByAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "minimumVotingPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "proposalCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "proposalThreshold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "proposals", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "propose", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "quorumVotes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "receipts", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "sAXIAL", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setExecutionDelay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMinimumVotingPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setProposalThreshold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setQuorumVotes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "state", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "vote", data: BytesLike): Result;

  events: {
    "ExecutionDelayChanged(uint256)": EventFragment;
    "MinimumVotingPeriodChanged(uint256)": EventFragment;
    "NewVote(uint256,address,uint256,uint256)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "ProposalCreated(uint256,address,string)": EventFragment;
    "ProposalExecuted(uint256,address)": EventFragment;
    "ProposalThresholdChanged(uint256)": EventFragment;
    "QuorumVotesChanges(uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ExecutionDelayChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MinimumVotingPeriodChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NewVote"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalThresholdChanged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "QuorumVotesChanges"): EventFragment;
}

export type ExecutionDelayChangedEvent = TypedEvent<
  [BigNumber],
  { newExecutionDelay: BigNumber }
>;

export type ExecutionDelayChangedEventFilter =
  TypedEventFilter<ExecutionDelayChangedEvent>;

export type MinimumVotingPeriodChangedEvent = TypedEvent<
  [BigNumber],
  { newMinimumVotingPeriod: BigNumber }
>;

export type MinimumVotingPeriodChangedEventFilter =
  TypedEventFilter<MinimumVotingPeriodChangedEvent>;

export type NewVoteEvent = TypedEvent<
  [BigNumber, string, BigNumber, BigNumber],
  { proposalId: BigNumber; voter: string; support: BigNumber; votes: BigNumber }
>;

export type NewVoteEventFilter = TypedEventFilter<NewVoteEvent>;

export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  { previousOwner: string; newOwner: string }
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export type ProposalCreatedEvent = TypedEvent<
  [BigNumber, string, string],
  { proposalId: BigNumber; proposer: string; title: string }
>;

export type ProposalCreatedEventFilter = TypedEventFilter<ProposalCreatedEvent>;

export type ProposalExecutedEvent = TypedEvent<
  [BigNumber, string],
  { proposalId: BigNumber; executor: string }
>;

export type ProposalExecutedEventFilter =
  TypedEventFilter<ProposalExecutedEvent>;

export type ProposalThresholdChangedEvent = TypedEvent<
  [BigNumber],
  { newProposalThreshold: BigNumber }
>;

export type ProposalThresholdChangedEventFilter =
  TypedEventFilter<ProposalThresholdChangedEvent>;

export type QuorumVotesChangesEvent = TypedEvent<
  [BigNumber],
  { newQuorumVotes: BigNumber }
>;

export type QuorumVotesChangesEventFilter =
  TypedEventFilter<QuorumVotesChangesEvent>;

export interface Governance extends BaseContract {
  contractName: "Governance";
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: GovernanceInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    EXECUTION_DELAY_MAXIMUM(overrides?: CallOverrides): Promise<[BigNumber]>;

    EXECUTION_DELAY_MINIMUM(overrides?: CallOverrides): Promise<[BigNumber]>;

    EXPIRATION_PERIOD(overrides?: CallOverrides): Promise<[BigNumber]>;

    PROPOSAL_THRESHOLD_MAXIMUM(overrides?: CallOverrides): Promise<[BigNumber]>;

    PROPOSAL_THRESHOLD_MINIMUM(overrides?: CallOverrides): Promise<[BigNumber]>;

    QUORUM_VOTES_MAXIMUM(overrides?: CallOverrides): Promise<[BigNumber]>;

    QUORUM_VOTES_MINIMUM(overrides?: CallOverrides): Promise<[BigNumber]>;

    VOTING_PERIOD_MAXIMUM(overrides?: CallOverrides): Promise<[BigNumber]>;

    VOTING_PERIOD_MINIMUM(overrides?: CallOverrides): Promise<[BigNumber]>;

    constructProposalExecutionContexts(
      _labels: string[],
      _targets: string[],
      _values: BigNumberish[],
      _data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[Governance.ProposalExecutionContextListStructOutput]>;

    constructProposalMetadata(
      _title: string,
      _metadata: string,
      _votingPeriod: BigNumberish,
      _isBoolean: boolean,
      overrides?: CallOverrides
    ): Promise<[Governance.ProposalStructOutput]>;

    execute(
      _proposalId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    executionDelay(overrides?: CallOverrides): Promise<[BigNumber]>;

    getProposalVotes(
      proposalId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber[]]>;

    getReceipt(
      _proposalId: BigNumberish,
      _voter: string,
      overrides?: CallOverrides
    ): Promise<[Governance.ReceiptStructOutput]>;

    lastProposalByAddress(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    minimumVotingPeriod(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    proposalCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    proposalThreshold(overrides?: CallOverrides): Promise<[BigNumber]>;

    proposals(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        boolean,
        Governance.ProposalExecutionContextListStructOutput
      ] & {
        title: string;
        metadata: string;
        proposer: string;
        executor: string;
        startTime: BigNumber;
        votingPeriod: BigNumber;
        quorumVotes: BigNumber;
        executionDelay: BigNumber;
        isBoolean: boolean;
        executionContexts: Governance.ProposalExecutionContextListStructOutput;
      }
    >;

    propose(
      _metaData: Governance.ProposalStruct,
      _executionContexts: Governance.ProposalExecutionContextListStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    quorumVotes(overrides?: CallOverrides): Promise<[BigNumber]>;

    receipts(
      arg0: BigNumberish,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber, BigNumber] & {
        hasVoted: boolean;
        support: BigNumber;
        votes: BigNumber;
      }
    >;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    sAXIAL(overrides?: CallOverrides): Promise<[string]>;

    setExecutionDelay(
      _seconds: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setMinimumVotingPeriod(
      _seconds: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setProposalThreshold(
      _votes: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setQuorumVotes(
      _votes: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    state(
      _proposalId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[number]>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    vote(
      _proposalId: BigNumberish,
      _support: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  };

  EXECUTION_DELAY_MAXIMUM(overrides?: CallOverrides): Promise<BigNumber>;

  EXECUTION_DELAY_MINIMUM(overrides?: CallOverrides): Promise<BigNumber>;

  EXPIRATION_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

  PROPOSAL_THRESHOLD_MAXIMUM(overrides?: CallOverrides): Promise<BigNumber>;

  PROPOSAL_THRESHOLD_MINIMUM(overrides?: CallOverrides): Promise<BigNumber>;

  QUORUM_VOTES_MAXIMUM(overrides?: CallOverrides): Promise<BigNumber>;

  QUORUM_VOTES_MINIMUM(overrides?: CallOverrides): Promise<BigNumber>;

  VOTING_PERIOD_MAXIMUM(overrides?: CallOverrides): Promise<BigNumber>;

  VOTING_PERIOD_MINIMUM(overrides?: CallOverrides): Promise<BigNumber>;

  constructProposalExecutionContexts(
    _labels: string[],
    _targets: string[],
    _values: BigNumberish[],
    _data: BytesLike[],
    overrides?: CallOverrides
  ): Promise<Governance.ProposalExecutionContextListStructOutput>;

  constructProposalMetadata(
    _title: string,
    _metadata: string,
    _votingPeriod: BigNumberish,
    _isBoolean: boolean,
    overrides?: CallOverrides
  ): Promise<Governance.ProposalStructOutput>;

  execute(
    _proposalId: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  executionDelay(overrides?: CallOverrides): Promise<BigNumber>;

  getProposalVotes(
    proposalId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber[]>;

  getReceipt(
    _proposalId: BigNumberish,
    _voter: string,
    overrides?: CallOverrides
  ): Promise<Governance.ReceiptStructOutput>;

  lastProposalByAddress(
    arg0: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  minimumVotingPeriod(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  proposalCount(overrides?: CallOverrides): Promise<BigNumber>;

  proposalThreshold(overrides?: CallOverrides): Promise<BigNumber>;

  proposals(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      string,
      string,
      string,
      string,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      boolean,
      Governance.ProposalExecutionContextListStructOutput
    ] & {
      title: string;
      metadata: string;
      proposer: string;
      executor: string;
      startTime: BigNumber;
      votingPeriod: BigNumber;
      quorumVotes: BigNumber;
      executionDelay: BigNumber;
      isBoolean: boolean;
      executionContexts: Governance.ProposalExecutionContextListStructOutput;
    }
  >;

  propose(
    _metaData: Governance.ProposalStruct,
    _executionContexts: Governance.ProposalExecutionContextListStruct,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  quorumVotes(overrides?: CallOverrides): Promise<BigNumber>;

  receipts(
    arg0: BigNumberish,
    arg1: string,
    overrides?: CallOverrides
  ): Promise<
    [boolean, BigNumber, BigNumber] & {
      hasVoted: boolean;
      support: BigNumber;
      votes: BigNumber;
    }
  >;

  renounceOwnership(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  sAXIAL(overrides?: CallOverrides): Promise<string>;

  setExecutionDelay(
    _seconds: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setMinimumVotingPeriod(
    _seconds: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setProposalThreshold(
    _votes: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setQuorumVotes(
    _votes: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  state(_proposalId: BigNumberish, overrides?: CallOverrides): Promise<number>;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  vote(
    _proposalId: BigNumberish,
    _support: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  callStatic: {
    EXECUTION_DELAY_MAXIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    EXECUTION_DELAY_MINIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    EXPIRATION_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSAL_THRESHOLD_MAXIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSAL_THRESHOLD_MINIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    QUORUM_VOTES_MAXIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    QUORUM_VOTES_MINIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    VOTING_PERIOD_MAXIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    VOTING_PERIOD_MINIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    constructProposalExecutionContexts(
      _labels: string[],
      _targets: string[],
      _values: BigNumberish[],
      _data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<Governance.ProposalExecutionContextListStructOutput>;

    constructProposalMetadata(
      _title: string,
      _metadata: string,
      _votingPeriod: BigNumberish,
      _isBoolean: boolean,
      overrides?: CallOverrides
    ): Promise<Governance.ProposalStructOutput>;

    execute(
      _proposalId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string[]>;

    executionDelay(overrides?: CallOverrides): Promise<BigNumber>;

    getProposalVotes(
      proposalId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;

    getReceipt(
      _proposalId: BigNumberish,
      _voter: string,
      overrides?: CallOverrides
    ): Promise<Governance.ReceiptStructOutput>;

    lastProposalByAddress(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    minimumVotingPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    proposalCount(overrides?: CallOverrides): Promise<BigNumber>;

    proposalThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    proposals(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        string,
        string,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        boolean,
        Governance.ProposalExecutionContextListStructOutput
      ] & {
        title: string;
        metadata: string;
        proposer: string;
        executor: string;
        startTime: BigNumber;
        votingPeriod: BigNumber;
        quorumVotes: BigNumber;
        executionDelay: BigNumber;
        isBoolean: boolean;
        executionContexts: Governance.ProposalExecutionContextListStructOutput;
      }
    >;

    propose(
      _metaData: Governance.ProposalStruct,
      _executionContexts: Governance.ProposalExecutionContextListStruct,
      overrides?: CallOverrides
    ): Promise<void>;

    quorumVotes(overrides?: CallOverrides): Promise<BigNumber>;

    receipts(
      arg0: BigNumberish,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<
      [boolean, BigNumber, BigNumber] & {
        hasVoted: boolean;
        support: BigNumber;
        votes: BigNumber;
      }
    >;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    sAXIAL(overrides?: CallOverrides): Promise<string>;

    setExecutionDelay(
      _seconds: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setMinimumVotingPeriod(
      _seconds: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setProposalThreshold(
      _votes: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    setQuorumVotes(
      _votes: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    state(
      _proposalId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<number>;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    vote(
      _proposalId: BigNumberish,
      _support: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "ExecutionDelayChanged(uint256)"(
      newExecutionDelay?: null
    ): ExecutionDelayChangedEventFilter;
    ExecutionDelayChanged(
      newExecutionDelay?: null
    ): ExecutionDelayChangedEventFilter;

    "MinimumVotingPeriodChanged(uint256)"(
      newMinimumVotingPeriod?: null
    ): MinimumVotingPeriodChangedEventFilter;
    MinimumVotingPeriodChanged(
      newMinimumVotingPeriod?: null
    ): MinimumVotingPeriodChangedEventFilter;

    "NewVote(uint256,address,uint256,uint256)"(
      proposalId?: null,
      voter?: null,
      support?: null,
      votes?: null
    ): NewVoteEventFilter;
    NewVote(
      proposalId?: null,
      voter?: null,
      support?: null,
      votes?: null
    ): NewVoteEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "ProposalCreated(uint256,address,string)"(
      proposalId?: null,
      proposer?: null,
      title?: null
    ): ProposalCreatedEventFilter;
    ProposalCreated(
      proposalId?: null,
      proposer?: null,
      title?: null
    ): ProposalCreatedEventFilter;

    "ProposalExecuted(uint256,address)"(
      proposalId?: null,
      executor?: null
    ): ProposalExecutedEventFilter;
    ProposalExecuted(
      proposalId?: null,
      executor?: null
    ): ProposalExecutedEventFilter;

    "ProposalThresholdChanged(uint256)"(
      newProposalThreshold?: null
    ): ProposalThresholdChangedEventFilter;
    ProposalThresholdChanged(
      newProposalThreshold?: null
    ): ProposalThresholdChangedEventFilter;

    "QuorumVotesChanges(uint256)"(
      newQuorumVotes?: null
    ): QuorumVotesChangesEventFilter;
    QuorumVotesChanges(newQuorumVotes?: null): QuorumVotesChangesEventFilter;
  };

  estimateGas: {
    EXECUTION_DELAY_MAXIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    EXECUTION_DELAY_MINIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    EXPIRATION_PERIOD(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSAL_THRESHOLD_MAXIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    PROPOSAL_THRESHOLD_MINIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    QUORUM_VOTES_MAXIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    QUORUM_VOTES_MINIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    VOTING_PERIOD_MAXIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    VOTING_PERIOD_MINIMUM(overrides?: CallOverrides): Promise<BigNumber>;

    constructProposalExecutionContexts(
      _labels: string[],
      _targets: string[],
      _values: BigNumberish[],
      _data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    constructProposalMetadata(
      _title: string,
      _metadata: string,
      _votingPeriod: BigNumberish,
      _isBoolean: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    execute(
      _proposalId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    executionDelay(overrides?: CallOverrides): Promise<BigNumber>;

    getProposalVotes(
      proposalId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getReceipt(
      _proposalId: BigNumberish,
      _voter: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    lastProposalByAddress(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    minimumVotingPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    proposalCount(overrides?: CallOverrides): Promise<BigNumber>;

    proposalThreshold(overrides?: CallOverrides): Promise<BigNumber>;

    proposals(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    propose(
      _metaData: Governance.ProposalStruct,
      _executionContexts: Governance.ProposalExecutionContextListStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    quorumVotes(overrides?: CallOverrides): Promise<BigNumber>;

    receipts(
      arg0: BigNumberish,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    sAXIAL(overrides?: CallOverrides): Promise<BigNumber>;

    setExecutionDelay(
      _seconds: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setMinimumVotingPeriod(
      _seconds: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setProposalThreshold(
      _votes: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setQuorumVotes(
      _votes: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    state(
      _proposalId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    vote(
      _proposalId: BigNumberish,
      _support: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    EXECUTION_DELAY_MAXIMUM(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    EXECUTION_DELAY_MINIMUM(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    EXPIRATION_PERIOD(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    PROPOSAL_THRESHOLD_MAXIMUM(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    PROPOSAL_THRESHOLD_MINIMUM(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    QUORUM_VOTES_MAXIMUM(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    QUORUM_VOTES_MINIMUM(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    VOTING_PERIOD_MAXIMUM(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    VOTING_PERIOD_MINIMUM(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    constructProposalExecutionContexts(
      _labels: string[],
      _targets: string[],
      _values: BigNumberish[],
      _data: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    constructProposalMetadata(
      _title: string,
      _metadata: string,
      _votingPeriod: BigNumberish,
      _isBoolean: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    execute(
      _proposalId: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    executionDelay(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getProposalVotes(
      proposalId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getReceipt(
      _proposalId: BigNumberish,
      _voter: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    lastProposalByAddress(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    minimumVotingPeriod(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposalCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposalThreshold(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    proposals(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    propose(
      _metaData: Governance.ProposalStruct,
      _executionContexts: Governance.ProposalExecutionContextListStruct,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    quorumVotes(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    receipts(
      arg0: BigNumberish,
      arg1: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    sAXIAL(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setExecutionDelay(
      _seconds: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setMinimumVotingPeriod(
      _seconds: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setProposalThreshold(
      _votes: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setQuorumVotes(
      _votes: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    state(
      _proposalId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    vote(
      _proposalId: BigNumberish,
      _support: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;
  };
}
